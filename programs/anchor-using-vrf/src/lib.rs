use anchor_lang::prelude::*;
use solana_program::sysvar::recent_blockhashes;

declare_id!("3gfec8ANuaWzkNhAR5QRjUvGqUjMYLJ3YnSVhgMkugqv");

vrf_sdk::declare_vrf_state!(VrfState);

#[program]
mod anchor_using_vrf {
    use super::*;

    pub fn init(ctx: Context<InitProgram>) -> anchor_lang::Result<()> {
        *ctx.accounts.state = ProgramState {
            owner: ctx.accounts.owner.key(),
            round: 0,
        };

        Ok(())
    }

    pub fn flip_a_coin(ctx: Context<CoinFlipRequest>, bet_amount: u64) -> anchor_lang::Result<()> {
        let data = ctx.accounts.recent_slothashes.data.borrow();
        let most_recent_slothash = &data[4..36];

        vrf_sdk::request_randomness(
            most_recent_slothash,
            &ctx.accounts.vrf,
            // This struct will be auto generated by anchor
            accounts::CoinFlipResult {
                owner: ctx.accounts.state.owner,
                state: ctx.accounts.state.key(),
                user: ctx.accounts.user.key(),
                vrf: ctx.accounts.vrf.key(),
            },
            // This struct will be auto generated by anchor
            instruction::OnCoinFlipped {
                vrf_result: Default::default(),
                bet_amount: bet_amount,
                _vrf_round: ctx.accounts.state.round,
            },
        )?;

        ctx.accounts.state.round = ctx.accounts.state.round.wrapping_add(1);

        // TODO: Subtract bet_amount from user wallet

        Ok(())
    }

    pub fn on_coin_flipped(
        ctx: Context<CoinFlipResult>,
        vrf_result: vrf_sdk::VrfResult,
        bet_amount: u64,
        _vrf_round: u64,
    ) -> anchor_lang::Result<()> {
        // save the result
        ctx.accounts.vrf.load_mut()?.vrf.result = vrf_result;

        let result = vrf_result.random(0..=1)?;
        if result == 0 {
            msg!("You lose!");
            return Ok(());
        }

        // TODO: Add double the bet_amount to user wallet
        msg!("You win: {}", bet_amount * 2);

        Ok(())
    }
}

#[derive(Accounts)]
pub struct InitProgram<'info> {
    #[account(mut)]
    owner: Signer<'info>,

    #[account(
		init,
		payer = owner,
		space = 128,
		seeds = [ b"program_state" ],
		bump
	)]
    state: Account<'info, ProgramState>,

    system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct CoinFlipRequest<'info> {
    #[account(mut)]
    user: Signer<'info>,

    #[account(mut, seeds = [ b"program_state" ], bump)]
    state: Account<'info, ProgramState>,

    #[account(
		init,
		payer = user,
		space = vrf_sdk::ACCOUNT_SIZE,
		seeds = [
			b"vrf",
			user.key().as_ref(),
			&state.round.to_be_bytes(),
		],
		bump,
	)]
    vrf: AccountLoader<'info, VrfState>,

    /// CHECK:
    #[account(address = recent_blockhashes::ID)]
    recent_slothashes: AccountInfo<'info>,

    system_program: Program<'info, System>,
}

#[derive(Accounts)]
#[instruction(vrf_result: vrf_sdk::VrfResult, bet_amount: u64, _vrf_round: u64)]
pub struct CoinFlipResult<'info> {
    owner: Signer<'info>,

    /// CHECK: We checked that vrf PDA seeds contains user pubkey
    #[account(mut)]
    user: AccountInfo<'info>,

    #[account(mut, has_one = owner, seeds = [ b"program_state" ], bump)]
    state: Account<'info, ProgramState>,

    #[account(
		mut,
		close = user,
		seeds = [
			b"vrf",
			user.key().as_ref(),
			&_vrf_round.to_be_bytes(),
		],
		bump
	)]
    vrf: AccountLoader<'info, VrfState>,
}

#[account]
pub struct ProgramState {
    owner: Pubkey,
    round: u64,
}
